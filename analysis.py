import argparse
from collections import Counter
import csv
from functools import cached_property
import functools
from pathlib import Path
from typing import Optional, Set, Tuple
import xml.etree.ElementTree as ET
import pandas as pd
import numpy as np
import datetime as dt
from dataclasses import dataclass

def strip_prefix(string: str, prefix: str) -> str:
    if string.startswith(prefix):
        return string[len(prefix):]
    return string

def pack_ordering(s):
    return s.str.lower()

# Note - it can be tempting to get the packname and song by splitting the key.
#     The pack name will be correct but the song name will be subtly wrong because it returns
#     the name of the folder and not the song title itself!
#     TO get the proper song name, you'll have to look at availablesongs (TODO write this better)

def chart_counts_for_each_pack(stats: TableStats, modes: dict[str, str]):
    data = stats.song_data(with_mem = False, keep_unavailable = False)

    def group_by_songs(df):
        return df[~df.index.get_level_values('key').duplicated()]

    def songs_and_charts(v: pd.DataFrame, column_prefix=''):
        if column_prefix != '':
            column_prefix = f'{column_prefix}_'    
        total_charts = v.groupby('pack').size().rename(f'{column_prefix}charts')
        total_songs = group_by_songs(v).groupby('pack').size().rename(f'{column_prefix}songs')
        return total_songs, total_charts

    # note: there might be other chart types, like pump-single, pump-double, or weird ones like lights-cabinet
    # to avoid counting unplayable stuff, we'll filter "total charts" to only the requested modes
    total = songs_and_charts(data.loc[pd.IndexSlice[:, modes.keys(), :]])
    per_steptype = []
    for steptype,label in modes.items():
        columns = songs_and_charts(data.loc[pd.IndexSlice[:, [steptype], :]], label)
        per_steptype.extend(columns)

    v = pd.concat([*total, *per_steptype], axis=1).fillna(0).sort_index(key=pack_ordering)
    return v

def pack_difficulty_histogram(stats: TableStats, upper_limit: int = 27):
    normal = data[data.meter.fillna(0) < upper_limit].groupby(['pack', 'meter']).size().to_frame()
    above = (
        data[data.meter >= upper_limit].groupby(['pack']).size().to_frame()
        .assign(meter=upper_limit).set_index('meter', append=True)
    )
    total = normal.combine_first(above)
    normalized = total / total.groupby('pack').max()
    histogram = normalized.unstack().sort_index(key=pack_ordering)
    return histogram

def most_played_charts(stats: TableStats):
    most_played_charts = stats.song_data(with_mem = False, keep_unavailable = True).sort_values('playcount', ascending=False).head(50)
    
    # Pack / Song / Steptype (Singles / Doubles) / Difficulty (Expert) / Meter (9) / Playcount / Last played
    a = (
        most_played_charts
        .join(stats.song_shorthand)
        .reset_index(level='difficulty')
        [['pack', 'song', 'stepfull', 'difficulty', 'meter', 'playcount', 'lastplayed']]
    )
    return a

def most_played_packs(stats: TableStats, N: int = 10):
    v = stats.song_data(with_mem=False, keep_unavailable=True)

    # calculate the most played packs
    most_played_packs = (
        v.groupby('pack')
        .agg({'playcount': 'sum', 'lastplayed': 'max'})
        .sort_values(by='playcount', ascending=False)
    )

    # calculate the N most played charts per pack
    place = v.sort_values('playcount', ascending=False).groupby('pack').cumcount() + 1
    x = v.assign(place=place)
    x = x[x.place <= N].join(stats.song_shorthand)
    y = x.reset_index().set_index(['pack', 'place'])

    most_played_songs_in_pack = (
        y[['shorthand', 'playcount']]
        .apply(lambda row: "({playcount}) {shorthand}".format(**row), axis=1)
        .unstack('place')
    )

    s = most_played_packs.join(most_played_songs_in_pack).reset_index()
    return s


def recently_played_packs(stats: TableStats):
    last_played_packs = (
        stats.song_data(with_mem=False, keep_unavailable=True)
        .groupby('pack')
        .agg({'lastplayed': 'max'})
        .sort_values(by='lastplayed', ascending=False)
    )
    v = last_played_packs.reset_index()
    return v

import openpyxl
from openpyxl import Workbook, load_workbook
from openpyxl.cell import Cell
from openpyxl.comments import Comment
from openpyxl.styles import Alignment, Fill, PatternFill
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet

def create_general_sheet(ws: Worksheet):
    
    pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog='analysis.py',
        description='',
    )

    parser.add_argument('path', help='Path to Stats.xml.')
    parser.add_argument('song_listing', help='Path to file generated by getavailablesongs.py.')
    parser.add_argument('--output', default="output.json", help='Output path.')

    args = parser.parse_args(['Stats.xml', 'available.csv'])

    s = TableStats()
    s.fill_stats_xml(Path(args.path))      # fluent api
    s.fill_song_listing(Path(args.song_listing))

    data = most_played_charts(s)
    # print(data)

    # I'm goig to have
    #   a script which outputs every data table (as csvs? json?)
    #       a simple javascript renderer? (drag in a data file: tabs, simple table rendering)
    #       AND a sample google sheets where you can paste in the tables
    #
    #       the javascript renderer is because it takes no work. google sheets requires copy pasting multiple times.
    #       tables could be dynamic size (difficulty histogram)
    #           TODO: make difficulty histogram have a lower end too?
    #                 make it have a step besides 1
    #                 this is getting too wide... just keep it simple
    #
    #       could export to excel, and import into google sheets
    #       making excel spreadsheets is really clunky though...
    #           but it would be equally as hard in javascript
    #           can copy paste data from excel into google sheets

    #   a notebook where you can compute each table individually
    #   

    # tree = ET.parse('Stats.xml')
    # root = tree.getroot()
    # songscores = root.find('SongScores')

    # playcount, highscores = allsongnames(songscores)

    # df_playedsongs = pd.DataFrame(playcount, columns=['key', 'steptype', 'difficulty', 'playcount', 'lastplayed'])
    # df_playedsongs = df_playedsongs.set_index(['key', 'steptype', 'difficulty'])

    # df_leaderboards = pd.DataFrame(highscores, columns=['key', 'steptype', 'difficulty', 'place', 'player', 'dp'])
    # df_leaderboards = df_leaderboards.set_index(['key', 'steptype', 'difficulty'])